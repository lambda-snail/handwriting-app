@page "/analyze"
@using HandwritingApp.Services
@using Azure.Storage.Blobs
@using Azure.Storage.Blobs.Models
@using Azure

<MudDynamicTabs @ref="@_tabComponent" @bind-ActivePanelIndex="@_userIndex"
                AddTab="@AddTabCallback" CloseTab="@CloseTabCallback"
                AddIconToolTip="Click to add a new tab" CloseIconToolTip="Close tab. All data will be lost"
                PanelClass="px-4 py-6" Elevation="4" Rounded ApplyEffectsToContainer>
    @foreach (var tab in _userTabs)
    {
        <MudTabPanel ID="@tab.Id" Text="@tab.Label" ShowCloseIcon="@tab.ShowCloseIcon">
            @if (_blobs.Count > 1)
            {
                <MudSelect T="string" Label="Select File" AnchorOrigin="Origin.BottomCenter">
                    @foreach (var blob in _blobs)
                    {
                        <MudSelectItem Value="@blob.Name" />   
                    }
                </MudSelect>
            }
            else
            {
                <MudSkeleton Animation="Animation.Wave" />
            }
            
        </MudTabPanel>
    }
</MudDynamicTabs>

@code {

    public class TabView
    {
        public string Label { get; set; }
        public Guid Id { get; set; }
        public bool ShowCloseIcon { get; set; } = true;
    }

    [Inject]
    private IDocumentAnalysisService _documentIntelligence { get; set; }
    
    [Inject]
    private BlobServiceClient blobServiceClient { get; set; }

    private MudDynamicTabs _tabComponent;
    private List<TabView> _userTabs = new();
    private int _userIndex;
    bool _stateHasChanged;
    private List<BlobItem> _blobs = new();

    protected override async Task OnInitializedAsync()
    {
        var containerClient = blobServiceClient.GetBlobContainerClient("documents");
        var blobsIterator = containerClient.GetBlobsAsync();

        await PopulateGrid(blobsIterator);
    }

    private async Task PopulateGrid(AsyncPageable<BlobItem> blobsIterator)
    {
        List<BlobItem> list = new();
        await foreach (var blob in blobsIterator)
        {
            list.Add(blob);
        }

        _blobs = list;
    }
    
    void RestoreUserTabs()
    {
        _userTabs.Clear();
        _stateHasChanged = true;
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        RestoreUserTabs();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if (_stateHasChanged)
        {
            _stateHasChanged = false;
            StateHasChanged();
        }
    }

    public void AddTab(Guid id)
    {
        _userTabs.Add(new TabView { Id = id, Label = "dynamic tab" });
        _userIndex = _userTabs.Count - 1; // Automatically switch to the new tab.
        _stateHasChanged = true;
    }

    public void RemoveTab(Guid id)
    {
        var tabView = _userTabs.SingleOrDefault((t) => Equals(t.Id, id));
        if (tabView is not null)
        {
            _userTabs.Remove(tabView);
            _stateHasChanged = true;
        }
    }

    void AddTabCallback() => AddTab(Guid.NewGuid());
    void CloseTabCallback(MudTabPanel panel) => RemoveTab((Guid)panel.ID);
    
    private async Task UploadFile(IReadOnlyList<IBrowserFile> files)
    {
        if (files.Count != 1) return;

        var file = files.First();
        await using var stream = file.OpenReadStream();
        using var seekableStream = new MemoryStream();
        await stream.CopyToAsync(seekableStream);

        var fileName = file.Name;
        
        var result = await _documentIntelligence.AnalyzeHandwriting(seekableStream);
    }
}